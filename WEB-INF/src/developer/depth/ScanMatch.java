package developer.depth;

import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.FileChannel;


public class ScanMatch {
	
	/*
	 * read 320x240 frame before move, store in variable: short[] frameBefore
	 * then, move bot -- linear or rotation
	 * read another 320x340 frame, store in variable: short[] frameAfter
	 * if linear move forward 0.6m:
	 * 		resample frameBefore (lower resolution)...? 32x24 (instead of averaging, take *closest* pixel??)
	 * 		resample frameAfter, ctr-scale up to match distance checking for		
	 * 			-tricky float operation or what? closest pixel as well?
	 * 		overlay frameBefore over frameAfter in various positions, choose closest match
	 * 		check for range: +/- 50% guessed distance (2mm increments), +/- 10 deg X, +/- 10 deg Y (resolution incrm.)
	 * 			-check for each range starting from *centers* - if progress is getting consistently WORSE, quit
	 * 		scale-resampled frameAfters are good for +/-5mm (ie., 1 resampled frameAfter for 10 possible positions)
	 * 
	 * 
	 */
	
	int width=320;
	int height=240;
//	int res = 10; // re-samples 320x240 to 32x24
	short[] frameBefore = null;
	short[] frameAfter = null;
	
	/**
	 * Load framedata from file. 
	 * @param f file to be loaded
	 * @return short integer array containing each pixel depth
	 */
	public short[] getFrame(File f) {
		
		ByteBuffer frameData = null;
		short[] result = new short[width*height];

		try {

			FileInputStream file = new FileInputStream(f);
			FileChannel ch = file.getChannel();
			frameData = ByteBuffer.allocate((int) width*height*2);
			ch.read(frameData.order(ByteOrder.LITTLE_ENDIAN));
			ch.close();
			file.close();

		} catch (IOException e) {
			e.printStackTrace();
		}
		
    	int i = 0;
    	for (int y=0; y<height; y++) {
			for (int x=0; x<width; x++) {
		        
		        int p = ((width * y)+x)*2;
		        short depth = frameData.getShort(p);
		        result[i] = depth;
		        i++;
			}	
    	}
    	
		return result; 


	}
	
	/**
	 * Convert full scan into lower resolution 2-dimensional array of closest pixels
	 * @param framePixels short[] array of 16-bit depth data
	 * @return int[][] xy array of closest pixels
	 */
	public int[][] resampleClosestPixel(short[] framePixels, int res) {
		
		int[][] result = new int[width/res][height/res]; //TODO: may need to add or subtract 1?
		int xx;
		int yy;
		int closestPixel;
		
		for (int x = 0; x < width; x += res) {			
			for (int y=0; y<height; y+= res) {

				closestPixel = 999999;
				for (xx=0; xx<res; xx++) {
					for (yy=0; yy<res; yy++) {
						int p = framePixels[x + xx + (y+yy)*width];
						if (p !=0 && p < closestPixel) {
							closestPixel = p;
						} 
					}
				}
				result[x/res][y/res] = closestPixel;
				
			}
		}
		
		return result;
	}
	
	/**
	 * Re-position xy of each cell from 2-dimensional array based on distance moved-guess. Only over-write
	 * cells if closer 
	 * @param frameCells 2-dimensional array, previously generated by resampleClosestPixel()
	 * @param distance in meters of travel (guess)
	 * @return int[][] xy array of closest pixels 
	 */
	public int[][] scaleClosestPixels(int[][] frameCells, float dMoved, int res) {
		//  N=n/(D-d)*D -- derived from: 
		//		https://docs.google.com/drawings/d/1zmwqU5HqGTvd9sBjpN0iLXc7LmAA54QiBJ_AL23HGL4/edit
		int[][] result = new int[width/res][height/res]; 

		for (int x=0; x<frameCells.length; x++) {
			for (int y=0; y<frameCells[0].length; y++) {

				int D = frameCells[x][y];
				float fX = (x-width/res/2) / (D-dMoved) * D + width/res/2;
				float fY = (y-height/res/2) / (D-dMoved) * D + height/res/2;
				int newX = Math.round(fX);
				int newY = Math.round(fY);
				
				if (newX >= 0 && newX < result.length && newY >=0 && newY < result[0].length) { // within range
					if (D < result[newX][newY] || result[newX][newY]==0)  result[newX][newY] = (int) (D-dMoved); // if unassigned or closer
				}
		
			}
		}
		
		return result;
	}
	
	/**
	 * Convert array of 16-bit pixels to depth image
	 * @param depth 16-bit pixel array
	 * @return width x height argb BufferedImage object
	 */
	public BufferedImage generateDepthFrameImg(short[] depth ) {
		final int maxDepthInMM = 3500; // 3500
		BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
		
		for(int y=0; y<height; y++) {
			for(int x=0; x<width; x++) {
				int hue = depth[x + y*width];
				if (hue > maxDepthInMM)	hue = maxDepthInMM;
				if (hue != 0) {
					hue = 255 - (int) ((float) (hue)/maxDepthInMM * 255f);
				}

				int argb = (hue<<16) + (0<<8) + hue;
				img.setRGB(width-x-1, y, argb);    // flip horiz
			}
		}
		
		return img;
	}
	
	
	/**
	 * Convert resampled matrix back into pixel array.
	 * @param frameCells resampled 2-dimensional array matrix to be converted
	 * @return width x height 16-bit integer array of pixels
	 */
	public short[] cellsToPixels(int[][] frameCells, int res) {
		short[] result = new short[width*height];

		for (int x=0; x<frameCells.length; x++) {
			for (int y=0; y<frameCells[x].length; y++) {
				for (int xx=0; xx<res; xx++) {
					for (int yy=0; yy<res; yy++) {
						result[(y*res+yy)*width+x*res+xx] = (short) frameCells[x][y];
					}
				}
			}
		}
		
		return result;
	}
	
	
    public static void main(String[] args) {
    	ScanMatch s = new ScanMatch();
    	s.frameBefore = s.getFrame(new File("C:\\temp\\xtion1.raw")); 
    	s.frameAfter = s.getFrame(new File("C:\\temp\\xtion2.raw"));
    	System.out.println(Integer.toString(s.frameBefore.length));

    }

}
